// NutriTracker Pro Service Worker - Optimized for Production
// Version: 1.0.0 - Compressed and Optimized

const CACHE_NAME='nutritracker-v1';const CACHE_VERSION='1.0.0';const CURRENT_CACHE=CACHE_NAME+'-'+CACHE_VERSION;const STATIC_CACHE_FILES=['/','/offline.html','/static/css/bootstrap.min.css','/static/css/app.min.css','/static/js/bootstrap.bundle.min.js','/static/js/app.min.js','/static/icons/icon-192x192.png','/static/icons/icon-512x512.png','/manifest.json'];const API_CACHE_TIME=5*60*1000;const NETWORK_TIMEOUT=3000;const MAX_CACHE_SIZE=50*1024*1024;const CACHE_STRATEGIES={NETWORK_FIRST:['api'],CACHE_FIRST:['static','images','fonts'],STALE_WHILE_REVALIDATE:['html','css','js']};const compressionSupport={gzip:true,brotli:true,deflate:true};self.addEventListener('install',event=>{console.log('[SW] Installing service worker v'+CACHE_VERSION);event.waitUntil(Promise.all([caches.open(CURRENT_CACHE).then(cache=>{console.log('[SW] Caching static files');return cache.addAll(STATIC_CACHE_FILES)}),self.skipWaiting()]).then(()=>{console.log('[SW] Static files cached successfully')}).catch(error=>{console.error('[SW] Failed to cache static files:',error)}))});self.addEventListener('activate',event=>{console.log('[SW] Activating service worker v'+CACHE_VERSION);event.waitUntil(Promise.all([caches.keys().then(cacheNames=>{return Promise.all(cacheNames.map(cacheName=>{if(cacheName.startsWith(CACHE_NAME)&&cacheName!==CURRENT_CACHE){console.log('[SW] Deleting old cache:',cacheName);return caches.delete(cacheName)}}))}),self.clients.claim(),cleanupOldCaches()]).then(()=>{console.log('[SW] Service worker activated')}))});self.addEventListener('fetch',event=>{const request=event.request;const url=new URL(request.url);if(request.method!=='GET'||url.origin!==location.origin){return}if(url.pathname.startsWith('/api/')){event.respondWith(handleAPIRequest(request));return}if(url.pathname.startsWith('/static/')||url.pathname==='/manifest.json'){event.respondWith(handleStaticRequest(request));return}if(request.headers.get('accept')?.includes('text/html')){event.respondWith(handleHTMLRequest(request));return}event.respondWith(handleDefaultRequest(request))});async function handleAPIRequest(request){const cacheKey=getCacheKey(request);try{const networkResponse=await Promise.race([fetch(request.clone()),timeoutPromise(NETWORK_TIMEOUT)]);if(networkResponse.ok){const cache=await caches.open(CURRENT_CACHE);const compressedResponse=await compressResponse(networkResponse.clone());cache.put(cacheKey,compressedResponse);await manageCacheSize(cache)}return networkResponse}catch(error){console.log('[SW] Network failed for API request, trying cache:',request.url);const cachedResponse=await caches.match(cacheKey);if(cachedResponse){return decompressResponse(cachedResponse)}return createOfflineResponse()}}async function handleStaticRequest(request){const cachedResponse=await caches.match(request);if(cachedResponse){updateCacheInBackground(request);return cachedResponse}try{const networkResponse=await fetch(request);if(networkResponse.ok){const cache=await caches.open(CURRENT_CACHE);cache.put(request.clone(),networkResponse.clone())}return networkResponse}catch(error){console.log('[SW] Failed to fetch static file:',request.url);throw error}}async function handleHTMLRequest(request){const cache=await caches.open(CURRENT_CACHE);const cachedResponse=await cache.match(request);const fetchPromise=fetch(request).then(networkResponse=>{if(networkResponse.ok){cache.put(request.clone(),networkResponse.clone())}return networkResponse}).catch(()=>{return caches.match('/offline.html')});if(cachedResponse){fetchPromise.catch(()=>{});return cachedResponse}return fetchPromise}async function handleDefaultRequest(request){try{return await fetch(request)}catch(error){const cachedResponse=await caches.match(request);if(cachedResponse){return cachedResponse}throw error}}function getCacheKey(request){const url=new URL(request.url);const searchParams=new URLSearchParams(url.search);searchParams.sort();url.search=searchParams.toString();return url.toString()}function timeoutPromise(timeout){return new Promise((_,reject)=>setTimeout(()=>reject(new Error('Network timeout')),timeout))}async function compressResponse(response){if(!response.body||response.headers.get('content-encoding')){return response}const contentType=response.headers.get('content-type')||'';if(!shouldCompress(contentType)){return response}try{const stream=new CompressionStream('gzip');const compressedStream=response.body.pipeThrough(stream);const compressedResponse=new Response(compressedStream,{status:response.status,statusText:response.statusText,headers:{...response.headers,'content-encoding':'gzip'}});return compressedResponse}catch(error){console.warn('[SW] Compression failed:',error);return response}}async function decompressResponse(response){const encoding=response.headers.get('content-encoding');if(!encoding||encoding==='identity'){return response}try{const stream=new DecompressionStream(encoding);const decompressedStream=response.body.pipeThrough(stream);const headers=new Headers(response.headers);headers.delete('content-encoding');return new Response(decompressedStream,{status:response.status,statusText:response.statusText,headers})}catch(error){console.warn('[SW] Decompression failed:',error);return response}}function shouldCompress(contentType){const compressibleTypes=['text/','application/json','application/javascript','application/xml','image/svg+xml'];return compressibleTypes.some(type=>contentType.includes(type))}function createOfflineResponse(){return new Response(JSON.stringify({success:false,error:'Offline - Request failed and no cached data available',offline:true,timestamp:new Date().toISOString()}),{status:503,statusText:'Service Unavailable',headers:{'Content-Type':'application/json','Cache-Control':'no-cache'}})}async function updateCacheInBackground(request){try{const response=await fetch(request);if(response.ok){const cache=await caches.open(CURRENT_CACHE);cache.put(request.clone(),response.clone())}}catch(error){console.log('[SW] Background update failed:',error)}}async function manageCacheSize(cache){try{const requests=await cache.keys();let totalSize=0;const sizePromises=requests.map(async request=>{const response=await cache.match(request);if(response&&response.body){const reader=response.body.getReader();let size=0;while(true){const{done,value}=await reader.read();if(done)break;size+=value.length}return{request,size}}return{request,size:0}});const sizes=await Promise.all(sizePromises);totalSize=sizes.reduce((sum,item)=>sum+item.size,0);if(totalSize>MAX_CACHE_SIZE){sizes.sort((a,b)=>b.size-a.size);const toDelete=sizes.slice(Math.floor(sizes.length*0.1));for(const{request}of toDelete){await cache.delete(request)}console.log(`[SW] Cache cleanup: removed ${toDelete.length} items`)}}catch(error){console.error('[SW] Cache size management failed:',error)}}async function cleanupOldCaches(){try{const cacheNames=await caches.keys();const oldCaches=cacheNames.filter(name=>name.startsWith('nutritracker')&&name!==CURRENT_CACHE);await Promise.all(oldCaches.map(name=>caches.delete(name)));console.log(`[SW] Cleaned up ${oldCaches.length} old caches`)}catch(error){console.error('[SW] Cache cleanup failed:',error)}}self.addEventListener('sync',event=>{console.log('[SW] Background sync triggered:',event.tag);if(event.tag==='background-sync'){event.waitUntil(doBackgroundSync())}});async function doBackgroundSync(){try{console.log('[SW] Processing background sync');const offlineData=await getOfflineData();if(offlineData.length>0){for(const data of offlineData){await syncData(data)}await clearOfflineData()}}catch(error){console.error('[SW] Background sync failed:',error)}}async function getOfflineData(){try{const cache=await caches.open(CURRENT_CACHE+'_offline');const requests=await cache.keys();return requests.map(req=>({url:req.url,method:req.method}))}catch(error){return[]}}async function syncData(data){try{const response=await fetch(data.url,{method:data.method});if(!response.ok){throw new Error('Sync failed')}console.log('[SW] Data synced successfully:',data.url)}catch(error){console.error('[SW] Failed to sync data:',data.url,error);throw error}}async function clearOfflineData(){try{await caches.delete(CURRENT_CACHE+'_offline');console.log('[SW] Offline data cleared')}catch(error){console.error('[SW] Failed to clear offline data:',error)}}self.addEventListener('push',event=>{if(!event.data)return;const data=event.data.json();const options={body:data.body,icon:'/static/icons/icon-192x192.png',badge:'/static/icons/badge-72x72.png',vibrate:[100,50,100],data:data.data,actions:data.actions||[],tag:data.tag||'general',requireInteraction:data.requireInteraction||false,silent:data.silent||false};event.waitUntil(self.registration.showNotification(data.title,options))});self.addEventListener('notificationclick',event=>{event.notification.close();const urlToOpen=event.notification.data?.url||'/';event.waitUntil(clients.matchAll({type:'window'}).then(clientList=>{for(const client of clientList){if(client.url===urlToOpen&&'focus'in client){return client.focus()}}if(clients.openWindow){return clients.openWindow(urlToOpen)}}))});self.addEventListener('message',event=>{if(event.data&&event.data.type==='SKIP_WAITING'){self.skipWaiting()}if(event.data&&event.data.type==='CACHE_URLS'){event.waitUntil(cacheUrls(event.data.urls))}});async function cacheUrls(urls){const cache=await caches.open(CURRENT_CACHE);return cache.addAll(urls)}self.addEventListener('periodicsync',event=>{if(event.tag==='nutrition-data-sync'){event.waitUntil(syncNutritionData())}});async function syncNutritionData(){try{console.log('[SW] Syncing nutrition data');const response=await fetch('/api/nutrition-info');if(response.ok){const cache=await caches.open(CURRENT_CACHE);cache.put('/api/nutrition-info',response.clone())}}catch(error){console.error('[SW] Nutrition data sync failed:',error)}}console.log('[SW] Service worker loaded successfully - Version',CACHE_VERSION);
